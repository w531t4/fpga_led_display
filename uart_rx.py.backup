#!/usr/bin/python

#This is an older version of uart_rx.py that i found. adding it until this repo gets in order
import serial
import time
serial_device = "/dev/ttyAMA0"
targetfile = "blah565.raw"
chunksize = 128
#f = open(targetfile, 'rb')
#fw = f.read()
index = 0
row = 0
total = ""
baudrate=115200
ser = serial.Serial(serial_device, baudrate, timeout=None)
def gen_bitstring(c):
        r_int = ord(c)
        if len(bin(r_int)[2:]) < 8:
                bitstring = '0'*(8-len(bin(r_int)[2:])) + bin(r_int)[2:]
        else:
                 bitstring = bin(r_int)[2:]
#    print bitstring
    return bitstring
def get_hexstring(bitstring, raw=True):
    retstring = ""
    for each in [bitstring[i:i+4] for i in range(0, len(bitstring), 4)]:
        retstring = retstring + hex(int(each,2))[2:]
    if (raw == True):
        return retstring
    else:
        return "0x" + retstring

def do_debug(c, length=8, title="", titlelength=24):
    binstring = ""
    for each in c:
        binstring = binstring + gen_bitstring(each)
    hexrep = get_hexstring(binstring, raw=False)
#    hexrep = "0x" + ('{:0>' + str(2) + '}').format(hex(int(binstring[2:length-2],2))[2:]) #+ ('{:0>' + str(2) + '}').format(hex(int(binstring[length-2:],2))[2:])
    r_c = ""
    s = binstring
    for each in [s[i:i+8] for i in range(0, len(s), 8)]:
        if (int(each,2) > 256):
            r_c = r_c + "X"
        else:
            r_c = r_c + chr(int(each,2))
    rstring = ('{0: <' + str(titlelength) + '}').format(title) \
            + " bin=" + ('{0: <' + str(2+16) + '}').format("0b"+binstring) \
            + " hex=" + ('{0: <' + str(2+4) + '}').format(hexrep) #\
#            + " char=" + r_c
    return rstring.replace('\n', '\\n').replace(chr(0x0c), '\\n').replace(chr(0x0b), '\\n')
structure = []
structure.append({ 'name': 'newline', 'size': 8 })
structure.append({ 'name': 'ram_a_data_in', 'size': 8 })
structure.append({ 'name': 'ram_a_clk_enable', 'size': 8 })
structure.append({ 'name': 'ram_a_address', 'size': 16 })
structure.append({ 'name': 'ram_a_data_out', 'size': 8 })
structure.append({ 'name': 'ram_a_write_enable', 'size': 8 })
structure.append({ 'name': 'ram_b_data_out', 'size': 16 })
structure.append({ 'name': 'ram_b_clk_enable', 'size': 8 })
structure.append({ 'name': 'ram_b_address', 'size': 16 })
structure.append({ 'name': 'ram_b_reset', 'size': 8 })
structure.append({ 'name': 'row_address_active', 'size': 16 })
structure.append({ 'name': 'row_address', 'size': 8 })
structure.append({ 'name': 'column_address', 'size': 8 })
structure.append({ 'name': 'rgb_enable', 'size': 8 })
structure.append({ 'name': 'brightness_enable', 'size': 8 })
structure.append({ 'name': 'brightness_mask', 'size': 8 })
structure.append({ 'name': 'pixel_rgb565_bottom', 'size': 16 })
structure.append({ 'name': 'pixel_rgb565_top', 'size': 16 })
#    print do_debug(c[1], title="ram_a_data_in")
#    print do_debug(c[2], title="ram_a_clk_enable")
#    print do_debug(c[4]+c[3], length=16, title="ram_a_address")
#    print do_debug(c[5], title="ram_a_data_out")
#    print do_debug(c[6], title="ram_a_write_enable")
#    print do_debug(c[8]+c[7] , length=16, title="ram_b_data_out" )
#    print do_debug(c[9], title="ram_b_clk_enable")
#    print do_debug(c[11]+c[10], length=16, title="ram_b_address")
#    print do_debug(c[12], title="ram_b_reset")
#    print do_debug(c[13], title="row_address_active")
#    print do_debug(c[14], title="row_address")
#    print do_debug(c[15], title="column_address")
#    print do_debug(c[16], title="rgb_enable")
#    print do_debug(c[17], title="brightness_enable")
#    print do_debug(c[18], title="brightness_mask")
#    print do_debug(c[20]+c[19], length=16, title="pixel_rgb565_bottom")
#    print do_debug(c[22]+c[21], length=16, title="pixel_rgb565_top")
size = 0
for each in [int(x['size']) for x in structure]:
    size += each
print size
largest_bytesize = 0
for each in [int(x['size']) for x in structure]:
    if (each > largest_bytesize):
        largest_bytesize = each
while True:
#    c = ser.read(1+1+1+2+1+1+2+1+2+1+10)[::-1]
    output = ""
    if ((size % 8) != 0):
        print "ERROR: sum of bitsize is not congruent with 8. alignment issues will result"
    c = ""
    while (len(c) < ((size/8)-1)):
        c = c + ser.read_until()
#            s = ""
#            for each in c:
#                    s = s+ format(ord(each), '02x')
#        print "c=", s[::-1]
#        print "len(c)=", len(c)

    if (len(c) > ((size/8)-1)):
        print "ERROR: received more than", size/8, " bytes"
#    c = ser.read(size/8)[::-1]
#    if hex(int(c[0],16)) != '0x0a':
#        print "ERROR: received string did not end in newline '0x0a'"
#        print
    c = c[::-1]
    output += "chars read:" + str(len(c))  + '\n'
    if False:
        continue
    else:
        position = 0
        for variable in structure:
            if variable['name'] == 'newline':
                position += 1
            else:
                vsize = variable['size']
                bytes_used = vsize/8
                vname = variable['name']
                renderstring = ""
                subsegment = c[position:position+bytes_used]
                #reverse the order, since things are currently c[0] c[1], we want c[1], c[0]
                subsegment = subsegment[::-1]
                output += do_debug(subsegment, length=vsize, title=vname) + '\n'
                position += bytes_used


#    s = ""
#    for each in c:
#        s = s+ format(ord(each), '02x')
#    print s[::-1]
    print(chr(27))
    print output
    #print
ser.close()
